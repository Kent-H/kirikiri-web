import React, {Fragment} from "react"
import Interpreter from "../interpreter"
import Anchor from "./anchor/anchor"
import ScrollDetect from "./scroll/scroll"
import Tag from "./tag/tag"
import Tokenize from "./tokenize"

const Parse = (props) => {
  const tokens = []
  Tokenize(tokens, props.gameState, props.stackFrame, props.target)

  const toDisplay = []
  const append = (Component) => {
    toDisplay.push(<Fragment key={toDisplay.length + 1}>{Component}</Fragment>)
  }

  let betweenText = []
  let layerContents = []

  tokens.forEach(token => {
    switch (token.type) {
      case ";": // comment
        // console.log(token.text) // ignore comments in general
        break
      case "t": // text
        layerContents = RenderChunk(betweenText, layerContents, append)
        betweenText = []
        append(<span>{token.text}</span>)
        break
      case "*": // link
        betweenText.push(token)
        break
      case "@": // full-line tag
      case "[": // inline tag
        betweenText.push(token)
        break
      case "EOF":
        layerContents = RenderChunk(betweenText, layerContents, append)
        betweenText = []
        // append(<div>--- end of {token.storage} ---</div>)
        break
      case "call": // jump or call statements require more page loading
        layerContents = RenderChunk(betweenText, layerContents, append)
        betweenText = []
        append(<Interpreter gameState={token.gameState}
                            storage={token.storage}
                            target={token.target}
                            returnFrame={token.returnFrame}/>)
        break
      default:
        console.log("warning: unhandled token type: " + token.type, token)
    }
  })
  return toDisplay
}

const debug = false
let uuid = 1

const RenderChunk = (tokens, layerContents, append) => {
  let isDivider = false
  let backgroundFolder = null
  let background = null

  let lastFrame = (layer) => {
    const animation = layers[layer || 0] || []
    return animation[animation.length - 1]
  }
  // retrieve the layer contents generated by the last animation
  let lastContents = (layer) => {
    return (lastFrame(layer) || {}).contents || {folder: "bgimage/", image: "black"}
  }

  let contents, frame

  let time = 0
  let endTime = 0

  let layers = layerContents
  let transition = []
  let animation = []

  tokens.forEach(token => {
    switch (token.type) {
      case ";": // comment
        // console.log(token.text) // ignore comments in general
        break
      case "*": // link
        append(<Anchor name={token.link}/>)
        break
      case "@": // full-line tag
      case "[": // inline tag
        if (debug) {
          append(<Tag command={token}/>)
        }
        switch (token.command.toLowerCase()) {
          case "imageex":
          case "image":
          case "image4demo":
          case "dashcombo":
          case "dashcomboT":
            if (token.args.layer && token.args.layer.startsWith("&")) {
              break
            }
            isDivider = true
            contents = {
              last: lastContents(token.args.layer),
              image: token.args.storage,
              folder: "bgimage/",
            }
            if (contents.last) {
              contents.last.next = contents
            }
            layers[token.args.layer || 0] = layers[token.args.layer || 0] || []
            layers[token.args.layer || 0].push({
              time: time,
              contents: contents,
              left: token.args.left ? parseInt(token.args.left, 10) : 0,
              top: token.args.top ? parseInt(token.args.top, 10) : 0,
              opacity: (token.args.opacity ? parseInt(token.args.opacity, 10) : 0) / 255,
            })
            background = token.args.storage
            backgroundFolder = "bgimage/"
            append(<Tag command={token} color="red"/>)
            // append(<ScrollDetect image={token.args.storage}
            //                      id={uuid++}
            //                      folder="bgimage/"
            //                      alt={token.command + " " + Object.keys(token.args).map(key => key === "*" ? " *" : " " + key + "=" + token.args[key]).join("")}/>)
            break
          case "fadein":
            if (token.args.layer && token.args.layer.startsWith("&")) {
              break
            }
            isDivider = true
            layers[token.args.layer || 0] = layers[token.args.layer || 0] || []
            contents = {
              last: lastContents(token.args.layer),
              image: token.args.file,
              folder: "bgimage/",
              transform: [token.args.fliplr ? "scaleX(-1)" : "", token.args.flipud ? "scaleY(-1)" : ""].join(" ") || undefined,
            }
            if (contents.last) {
              contents.last.next = contents
            }
            frame = lastFrame(token.args.layer) || {contents: {folder: "bgimage/", image: "black"}, top: 0, left: 0}
            frame = Object.assign({}, frame, {time: time})
            layers[token.args.layer || 0] = layers[token.args.layer || 0] || []
            layers[token.args.layer || 0].push(frame)
            layers[token.args.layer || 0].push({
              time: time + (token.args.time ? parseInt(token.args.time, 10) : 0),
              contents: contents,
              left: 0,
              top: 0,
            })
            // there must be a cleaner way to indicate that a layer has been removed
            layers.forEach(animation => {
              if (animation !== layers[token.args.layer || 0]) {
                if (lastContents(token.args.layer).image) {
                  animation.push({
                    contents: {},
                    time: time,
                  })
                }
              }
            })
            time += (token.args.time ? parseInt(token.args.time, 10) : 0)
            transition[token.args.layer || 0] = {method: token.args.method, time: token.args.time}
            background = token.args.file
            backgroundFolder = "bgimage/"
            append(<Tag command={token} color="red"/>)
            // append(<ScrollDetect image={token.args.file}
            //                      id={uuid++}
            //                      folder="bgimage/"
            //                      alt={token.command + " " + Object.keys(token.args).map(key => key === "*" ? " *" : " " + key + "=" + token.args[key]).join("")}/>)
            break
          case "move":
            if (token.args.layer && token.args.layer.startsWith("&")) {
              break
            }
            frame = Object.assign({}, lastFrame(token.args.layer), {time: time})
            layers[token.args.layer || 0] = layers[token.args.layer || 0] || []
            layers[token.args.layer || 0].push(frame)
            const pathRegex = /\((-?\d+),(-?\d+),(-?\d+)\)/y // read as many as we have
            let node
            while ((node = pathRegex.exec(token.args.path)) !== null) {
              layers[token.args.layer || 0].push(
                Object.assign({}, frame, {
                  time: time + parseInt(token.args.time, 10),
                  contents: lastContents(token.args.layer),
                  left: parseInt(node[1], 10),
                  top: parseInt(node[2], 10),
                  opacity: parseInt(node[3], 10) / 255,
                }))
            }
            let moveTime = time + parseInt(token.args.time, 10)
            endTime = endTime > moveTime ? endTime : moveTime
            append(<Tag command={token} color="red"/>)
            break
          case "wm":
            time = time > endTime ? time : endTime
            append(<Tag command={token} color="red"/>)
            break
          case "wait":
            time += parseInt(token.args.time, 10) || 0
            append(<Tag command={token} color="red"/>)
            break
          case "r":
            append(<div className="newline"/>)
            break
          case "cm":
            append(<div style={{height: "3em"}}/>)
            break
          case "macro":
            // on creation of a macro, there's nothing to render unless debugging
            if (debug) {
              append(<div style={{color: "darkred", marginLeft: "2em", border: "1px solid green"}}>
                {token.tokens.map(token => (<Tag command={token}/>))}
              </div>)
            }
            break
          case "return":
            // append(<div>--- returning from {token.from} (to {token.to}) ---</div>)
            break
          case "s":
            append("--- page generation halted at [s] ---")
            break
          default:
        }
        break
      case "EOF":
        append(<div>--- end of {token.storage} ---</div>)
        break
      case "call": // jump or call statements require more page loading
        append(<Interpreter gameState={token.gameState}
                            storage={token.storage}
                            target={token.target}
                            returnFrame={token.returnFrame}/>)
        break
      default:
        console.log("warning: unhandled token type: " + token.type, token)
    }
  })

  // save final frame for next animation block to use
  layerContents = []
  layers.forEach((animation, layer) => {
    layerContents[layer] = [Object.assign({}, animation[animation.length - 1], {time: 0})]
  })


  if (isDivider) {
    // determine transition
    // determine reverse transition
    append(<ScrollDetect image={background}
                         id={uuid++}
                         folder={backgroundFolder}
                         layers={layers}
                         alt=""/>)
  }
  return layerContents
}

export default Parse